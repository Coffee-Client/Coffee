/*
 * Copyright (c) 2022 Coffee Client, 0x150 and contributors. All rights reserved.
 */

package coffee.client.feature.module.impl.exploit;

import coffee.client.CoffeeMain;
import coffee.client.feature.config.BooleanSetting;
import coffee.client.feature.config.DoubleSetting;
import coffee.client.feature.config.EnumSetting;
import coffee.client.feature.gui.notifications.Notification;
import coffee.client.feature.module.Module;
import coffee.client.feature.module.ModuleType;
import coffee.client.feature.module.impl.world.XRAY;
import coffee.client.helper.render.Renderer;
import coffee.client.helper.util.Utils;
import net.minecraft.block.Block;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.client.util.math.MatrixStack;
import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.util.math.Vec3d;

import java.awt.Color;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;

public class AntiAntiXray extends Module {

    final Queue<BlockPos> toScan = new ArrayDeque<>();
    final List<BlockPos> renders = new ArrayList<>();
    final List<BlockPos> visitsAfter = new ArrayList<>();
    final DoubleSetting range = this.config.create(new DoubleSetting.Builder(16).name("Range").description("How far to scan").min(2).max(64).precision(0).get());
    final DoubleSetting customYSize = this.config.create(new DoubleSetting.Builder(-1).name("Custom Y size").description("Custom Y size of the scanner box (-1 to disable)").min(-1).max(128).precision(0).get());
    final DoubleSetting skipDistance = this.config.create(new DoubleSetting.Builder(2).name("Skip distance").description("In which interval to skip blocks").min(0).max(6).precision(1).get());
    final EnumSetting<Mode> mode = this.config.create(new EnumSetting.Builder<>(Mode.Ores).name("Mode").description("Which blocks to scan").get());
    final DoubleSetting blocksPerTick = this.config.create(new DoubleSetting.Builder(10).name("Blocks per tick").description("How many blocks to scan per tick").min(1).max(20).precision(0).get());
    final DoubleSetting delay = this.config.create(new DoubleSetting.Builder(0).name("Delay").description("How much to wait between scan bursts").min(0).max(20).precision(0).get());
    final BooleanSetting showAura = this.config.create(new BooleanSetting.Builder(false).name("Show aura").description("Shows a nice effect around the scanner (VERY performance intensive)").get());
    List<BlockPos> permanentToScan = new ArrayList<>();
    Vec3d startPos;
    int scanned = 0;
    int delayPassed = 0;
    BlockPos latestGoal = null;

    public AntiAntiXray() {
        super("AntiAntiXray", "Bypasses most anti xray plugins", ModuleType.EXPLOIT);
    }

    boolean isBlockValid(Block b) {
        return switch (mode.getValue()) {
            case Ores -> XRAY.blocks.contains(b); // ores mode
            case Stone -> b == Blocks.STONE; // stone mode
            case Diamond -> b == Blocks.DIAMOND_ORE; // diamond ore mode
            case Redstone -> b == Blocks.REDSTONE_ORE; // redstone ore mode
            case Iron -> b == Blocks.IRON_ORE; // iron ore mode
            case Netherite -> b == Blocks.ANCIENT_DEBRIS; // ancient debris mode
            case Everything -> true; // everything mode
        };
    }

    @Override
    public void tick() {
        if (CoffeeMain.client.player == null || CoffeeMain.client.getNetworkHandler() == null) {
            return;
        }
        if (toScan.size() == 0) {
            Notification.create(5000, "AntiAntiXray", Notification.Type.SUCCESS, "Done scanning ores!");
            toggle();
            return;
        }
        if (delayPassed > delay.getValue()) {
            delayPassed = 0;
        } else {
            delayPassed++;
            return;
        }
        renders.clear();
        for (int i = 0; i < blocksPerTick.getValue(); i++) {
            if (toScan.size() == 0) {
                break;
            }
            BlockPos current = toScan.poll();
            renders.add(current);
            scanned++;

            PlayerActionC2SPacket p = new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.ABORT_DESTROY_BLOCK, current, Direction.DOWN);
            CoffeeMain.client.getNetworkHandler().sendPacket(p);
        }
    }

    @Override
    public void enable() {
        if (CoffeeMain.client.player == null || CoffeeMain.client.world == null) {
            return;
        }
        toScan.clear();
        scanned = 0;
        startPos = CoffeeMain.client.player.getPos();
        BlockPos ppos = CoffeeMain.client.player.getBlockPos();
        Vec3d lastPos = Vec3d.ZERO;
        int rangeMid = (int) (range.getValue() / 2);
        int ry = customYSize.getValue() == -1 ? rangeMid : (int) (customYSize.getValue() / 2);
        for (int y = ry; y > -ry; y--) {
            for (int x = -rangeMid; x < rangeMid; x++) {
                for (int z = -rangeMid; z < rangeMid; z++) {
                    BlockPos current = ppos.add(x, y, z);
                    BlockState bs = CoffeeMain.client.world.getBlockState(current);
                    Vec3d currentPos = new Vec3d(current.getX(), current.getY(), current.getZ());
                    if (!bs.isAir() && lastPos.distanceTo(currentPos) >= skipDistance.getValue()) {
                        if (isBlockValid(bs.getBlock())) {
                            toScan.add(current);
                            lastPos = currentPos;
                        }
                    }
                }
            }
        }
        permanentToScan = new ArrayList<>(toScan);
    }

    @Override
    public void disable() {
        visitsAfter.clear();
        latestGoal = null;
    }

    @Override
    public String getContext() {
        return "[" + scanned + "S;" + toScan.size() + "R]";
    }

    @Override
    public void onWorldRender(MatrixStack matrices) {
        for (BlockPos latestScan : renders.toArray(new BlockPos[0])) {
            Renderer.R3D.renderFilled(matrices, Utils.getCurrentRGB(), new Vec3d(latestScan.getX(), latestScan.getY(), latestScan.getZ()), new Vec3d(1, 1, 1));
        }
        double mid = this.range.getValue() / 2;
        Vec3d s = new Vec3d(mid, mid, mid);
        Vec3d ppOrigin = startPos;
        Vec3d boxOrigin = ppOrigin.subtract(s);
        Renderer.R3D.renderOutline(matrices, Utils.getCurrentRGB(), boxOrigin, s.multiply(2));

        if (customYSize.getValue() != -1) {
            Vec3d sub = new Vec3d(mid, customYSize.getValue() / 2d, mid);
            Renderer.R3D.renderOutline(matrices, Color.CYAN, ppOrigin.subtract(sub), sub.multiply(2));
        }

        if (latestGoal != null) {
            Renderer.R3D.renderLine(matrices, Color.CYAN, Renderer.R3D.getCrosshairVector(), new Vec3d(latestGoal.getX(), latestGoal.getY(), latestGoal.getZ()).add(0.5, 0.5, 0.5));
        }

        if (renders.size() == 0 || !showAura.getValue()) {
            return;
        }
        double maxDist = 5;
        for (BlockPos bp : permanentToScan) {
            Vec3d vv = new Vec3d(bp.getX(), bp.getY(), bp.getZ());
            double d = 0;
            int i = 0;
            for (BlockPos render : renders) {
                Vec3d e = new Vec3d(render.getX(), render.getY(), render.getZ());
                double ee = vv.distanceTo(e) / maxDist;
                if (ee > 1) {
                    continue;
                }
                d += ee;
                i++;
            }
            if (i == 0) {
                continue;
            }
            d /= i;
            d = Math.abs(1 - d);
            Color c = Color.getHSBColor((float) d, 0.6f, 1f);
            c = Renderer.Util.modify(c, -1, -1, -1, (int) Math.floor(d * 255d));
            Renderer.R3D.renderOutline(matrices, c, vv, new Vec3d(1, 1, 1));
        }
    }

    @Override
    public void onHudRender() {

    }

    public enum Mode {
        Ores, Stone, Diamond, Redstone, Iron, Netherite, Everything
    }
}
